<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker入门</title>
    <url>/article/cks4y3x620000a6qvalu2eki2/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.cnblogs.com/mrhelloworld/p/docker2.html">Docker 架构及工作原理</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></p>
<p><a href="https://docs.docker.com/config/daemon/systemd/">Docker官方文档</a></p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在开发中，会遇到一个头疼的问题，便是环境配置问题，docker可以做到将原始开发环境一并打包的功能，这样就避免了运行环境差异造成的不必要问题</p>
<p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。Linux容器是一种虚拟化技术，不同于虚拟机的是，<strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>它具有以下优势：</p>
<ul>
<li>启动快</li>
<li>资源占用小</li>
<li>体积小</li>
</ul>
<h2 id="Docker结构"><a href="#Docker结构" class="headerlink" title="Docker结构"></a>Docker结构</h2><p><img src="https://mrhelloworld.com/resources/articles/docker/7868545-060cc40d94102469.jpg"></p>
<p>通过上图可以得知，<code>Docker</code> 在运行时分为 <code>Docker 引擎（服务端守护进程）</code> 和 <code>客户端工具</code>，即它是是服务器—-客户端架构，我们日常使用各种 <code>docker 命令</code>，其实就是在使用 <code>客户端工具</code> 与 <code>Docker 引擎</code> 进行交互。</p>
<h2 id="Docker名次及概念解释"><a href="#Docker名次及概念解释" class="headerlink" title="Docker名次及概念解释"></a>Docker名次及概念解释</h2><h3 id="Client-客户端"><a href="#Client-客户端" class="headerlink" title="Client 客户端"></a>Client 客户端</h3><p>Docker 是一个客户端-服务器（C/S）架构程序。Docker 客户端只需要向 Docker 服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具 Docker 以及一整套 RESTful API。<strong>你可以在同一台宿主机上运行 Docker 守护进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程。</strong></p>
<h3 id="Host-主机（Docker引擎）"><a href="#Host-主机（Docker引擎）" class="headerlink" title="Host 主机（Docker引擎）"></a>Host 主机（Docker引擎）</h3><p>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</p>
<h3 id="Image-镜像"><a href="#Image-镜像" class="headerlink" title="Image 镜像"></a>Image 镜像</h3><p>简单的理解，Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运行在 Linux 内核的程序以及相应的数据。</p>
<p>通过镜像启动一个容器，一个镜像就是一个可执行的包，其中包括运行应用程序所需要的所有内容：包含代码，运行时间，库，环境变量和配置文件等。</p>
<p>Docker 把 App 文件打包成为一个镜像，并且采用类似多次快照的存储技术，可以实现：</p>
<ul>
<li>多个 App 可以共用相同的底层镜像（初始的操作系统镜像）；</li>
<li>App 运行时的 IO 操作和镜像文件隔离；</li>
<li>通过挂载包含不同配置/数据文件的目录或者卷（Volume），单个 App 镜像可以用来运行无数个不同业务的容器。</li>
</ul>
<h3 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container 容器"></a>Container 容器</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的<strong>类和实例</strong>一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<h3 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h3><p>Docker 支持通过扩展现有镜像，创建新的镜像。<em>实际上，Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。</em></p>
<p><img src="https://mrhelloworld.com/resources/articles/docker/12180844322018196a29c55c8de4a2.png"></p>
<p>从上图可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p>
<p>镜像分层最大的一个好处就是共享资源。比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 /etc 下的文件，这时其他容器的 /etc 是不会被修改的，<strong>修改只会被限制在单个容器内</strong>。这就是容器 <strong>Copy-on-Write</strong> 特性。</p>
<h3 id="容器层"><a href="#容器层" class="headerlink" title="容器层"></a>容器层</h3><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<p><img src="https://mrhelloworld.com/resources/articles/docker/121808444920186f41cc40362cc7ef.png"></p>
<p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有<strong>容器层是可写的，容器层下面的所有镜像层都是只读的</strong>。</p>
<p>镜像层数量可能会很多，<strong>所有镜像层会联合在一起组成一个统一的文件系统</strong>。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。<strong>在容器层中，用户看到的是一个叠加之后的文件系统。</strong>因此便好理解，为什么对基层镜像的修改，会被限制在单一容器内：在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，<strong>立即将其复制到容器层，然后修改之</strong>，这便是 <strong>Copy-on-Write</strong></p>
<table>
<thead>
<tr>
<th align="left">文件操作</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">添加文件</td>
<td align="left">在容器中创建文件时，新文件被添加到容器层中。</td>
</tr>
<tr>
<td align="left">读取文件</td>
<td align="left">在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存。</td>
</tr>
<tr>
<td align="left">修改文件</td>
<td align="left">在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</td>
</tr>
<tr>
<td align="left">删除文件</td>
<td align="left">在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中<strong>「记录下此删除操作」</strong>。（只是记录删除操作）</td>
</tr>
</tbody></table>
<h3 id="Volume-数据卷"><a href="#Volume-数据卷" class="headerlink" title="Volume 数据卷"></a>Volume 数据卷</h3><p>数据卷可以将数据持久化到我们本地的宿主机上，与容器间实现数据共享，简单的说就是将宿主机的目录映射到容器中的目录，应用程序在容器中的目录读写数据会同步到宿主机上，这样容器产生的数据就可以持久化了，比如我们的数据库容器，就可以把数据存储到我们宿主机上的真实磁盘中。</p>
<h3 id="Registry-注册中心"><a href="#Registry-注册中心" class="headerlink" title="Registry 注册中心"></a>Registry 注册中心</h3><p>Docker 用 Registry 来保存用户构建的镜像。Registry 分为公共和私有两种。</p>
<p>Docker官方运营的Registry为<a href="%5Bhttps://hub.docker.com%5D(https://hub.docker.com/)">Docker Hub</a></p>
<p>一个 Docker Registry 中可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签对应该软件的各个版本。我们可以通过**<code>&lt;仓库名&gt;:&lt;标签&gt;</code> **的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong><code>latest</code></strong> 作为默认标签。</p>
<h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><h3 id="启动Docker服务"><a href="#启动Docker服务" class="headerlink" title="启动Docker服务"></a>启动Docker服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service 命令的用法</span></span><br><span class="line">$ sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># systemctl 命令的用法</span></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><h4 id="列出本机所有镜像"><a href="#列出本机所有镜像" class="headerlink" title="列出本机所有镜像"></a>列出本机所有镜像</h4><p><code>docker image ls</code></p>
<h4 id="删除指定镜像"><a href="#删除指定镜像" class="headerlink" title="删除指定镜像"></a>删除指定镜像</h4><p><code>docker image rm [imageName]</code></p>
<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p><code>docker image pull [imagePath]</code></p>
<p>例如：</p>
<p><code>docker image pull library/hello-world</code></p>
<p>这将会拉取 <code>library</code> 组的 <code>hello-world</code> 镜像，由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p>
<p><code>docker image pull hello-world</code></p>
<h4 id="创建一个容器实例"><a href="#创建一个容器实例" class="headerlink" title="创建一个容器实例"></a>创建一个容器实例</h4><p><code>docker container run [imageName]</code></p>
<p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p>
<p>常用参数：</p>
<ul>
<li><code>-p 3000:8000</code>：容器的 3000 端口映射到本机的 8000 端口。</li>
<li><code>-it</code>：容器的 Shell 映射到当前的 Shell，此时在本机窗口输入的命令，就会传入容器。</li>
<li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li>
<li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令，是<strong>附加指令</strong>。这里是启动 Bash，保证用户可以使用 Shell。</li>
<li><code>--rm</code>：在容器终止后自动销毁容器</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --rm -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure>



<p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p>
<h4 id="启动已有的容器"><a href="#启动已有的容器" class="headerlink" title="启动已有的容器"></a>启动已有的容器</h4><p><code>docker container start [containerID]</code></p>
<h4 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h4><p><code>docker container kill [containerID]</code></p>
<p>或</p>
<p><code> docker container stop [containerID]</code></p>
<p><strong>区别</strong></p>
<p><code>kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>
<p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>
<h4 id="查看容器输出"><a href="#查看容器输出" class="headerlink" title="查看容器输出"></a>查看容器输出</h4><p><code>docker container logs [containerID]</code></p>
<p>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p>
<h4 id="进入一个正在运行的容器"><a href="#进入一个正在运行的容器" class="headerlink" title="进入一个正在运行的容器"></a>进入一个正在运行的容器</h4><p><code>docker container exec [containerID]</code></p>
<p>用于进入一个正在运行的 docker 容器。如果运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。例如：</p>
<p><code>docker container exec -it [containerID] /bin/bash</code></p>
<h4 id="容器文件互拷"><a href="#容器文件互拷" class="headerlink" title="容器文件互拷"></a>容器文件互拷</h4><p>例如将容器中<code>/path/to/fule</code>拷贝到本地</p>
<p><code>docker container cp [containID]:[/path/to/file] .</code></p>
<p>如果需要将本地中文件拷贝到容器中，二者位置调换即可：</p>
<p><code>docker container cp . [containID]:[/path/to/file]</code></p>
<h4 id="列出本机所有容器"><a href="#列出本机所有容器" class="headerlink" title="列出本机所有容器"></a>列出本机所有容器</h4><p><strong>列出本机所有正在运行的容器</strong></p>
<p><code>docker container ls</code></p>
<p><strong>列出本机所有容器（包括终止的容器）</strong></p>
<p><code>docker container ls --all</code></p>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>若要彻底删除容器，则使用以下指令</p>
<p><code>docker container rm [containerID]</code></p>
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><h3 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h3><p>类似于git的<code>.gitignore</code>文件，目的是打包时排除指定的文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">.gitignore</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile 文件是一个文本文件，用来配置 image。Docker 会根据该文件生成二进制的 image 文件。</p>
<p>示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> node demos/01.js</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>FROM node:8.4</code>：表明该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li>
<li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li>
<li><code>WORKDIR /app</code>：表明指定接下来的工作路径为<code>/app</code>。</li>
<li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install --registry=https://registry.npm.taobao.org</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li>
<li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li>
<li><code>CMD node demos/01.js</code>：表示容器启动后自动执行<code>node demos/01.js</code>。</li>
</ul>
<p><strong>注意：</strong><code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件，而<code>CMD</code>命令则是在容器启动后执行。<strong>一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令</strong>。同时在指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令</p>
<h3 id="使用Dockerfile创建image"><a href="#使用Dockerfile创建image" class="headerlink" title="使用Dockerfile创建image"></a>使用Dockerfile创建image</h3><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure>

<p>上面代码中，</p>
<ul>
<li><code>-t</code>参数用来指定 image 文件的名字</li>
<li>冒号用于指定标签。如果不指定，默认的标签就是<code>latest</code>。</li>
<li>最后的点表示 Dockerfile 文件所在的路径</li>
</ul>
<h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p>假设将会在 <code>Docker Hub</code>上发布，首先需要去网站上注册一个账户，然后使用以下指令登陆：</p>
<p><code>docker login</code></p>
<p>接下里便可以为本地的 image 标注用户名和版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure>

<p>也可以不标注用户名，重新构建一下 image 文件。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure>

<p>最后便可以发布 image</p>
<p><code>docker image push [username]/[repository]:[tag]</code></p>
]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/cks4y3x650001a6qvdj6x3hfv/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
