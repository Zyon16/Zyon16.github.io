<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker入门</title>
    <url>/article/cks5vvvjq0001wcqv7xff772z/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://www.cnblogs.com/mrhelloworld/p/docker2.html">Docker 架构及工作原理</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></p>
<p><a href="https://docs.docker.com/config/daemon/systemd/">Docker官方文档</a></p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在开发中，会遇到一个头疼的问题，便是环境配置问题，docker可以做到将原始开发环境一并打包的功能，这样就避免了运行环境差异造成的不必要问题</p>
<p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。Linux容器是一种虚拟化技术，不同于虚拟机的是，<strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>它具有以下优势：</p>
<ul>
<li>启动快</li>
<li>资源占用小</li>
<li>体积小</li>
</ul>
<h2 id="Docker结构"><a href="#Docker结构" class="headerlink" title="Docker结构"></a>Docker结构</h2><p><img src="https://mrhelloworld.com/resources/articles/docker/7868545-060cc40d94102469.jpg"></p>
<p>通过上图可以得知，<code>Docker</code> 在运行时分为 <code>Docker 引擎（服务端守护进程）</code> 和 <code>客户端工具</code>，即它是是服务器—-客户端架构，我们日常使用各种 <code>docker 命令</code>，其实就是在使用 <code>客户端工具</code> 与 <code>Docker 引擎</code> 进行交互。</p>
<h2 id="Docker名词及概念解释"><a href="#Docker名词及概念解释" class="headerlink" title="Docker名词及概念解释"></a>Docker名词及概念解释</h2><h3 id="Client-客户端"><a href="#Client-客户端" class="headerlink" title="Client 客户端"></a>Client 客户端</h3><p>Docker 是一个客户端-服务器（C/S）架构程序。Docker 客户端只需要向 Docker 服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具 Docker 以及一整套 RESTful API。<strong>你可以在同一台宿主机上运行 Docker 守护进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程。</strong></p>
<h3 id="Host-主机（Docker引擎）"><a href="#Host-主机（Docker引擎）" class="headerlink" title="Host 主机（Docker引擎）"></a>Host 主机（Docker引擎）</h3><p>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</p>
<h3 id="Image-镜像"><a href="#Image-镜像" class="headerlink" title="Image 镜像"></a>Image 镜像</h3><p>简单的理解，Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运行在 Linux 内核的程序以及相应的数据。</p>
<p>通过镜像启动一个容器，一个镜像就是一个可执行的包，其中包括运行应用程序所需要的所有内容：包含代码，运行时间，库，环境变量和配置文件等。</p>
<p>Docker 把 App 文件打包成为一个镜像，并且采用类似多次快照的存储技术，可以实现：</p>
<ul>
<li>多个 App 可以共用相同的底层镜像（初始的操作系统镜像）；</li>
<li>App 运行时的 IO 操作和镜像文件隔离；</li>
<li>通过挂载包含不同配置/数据文件的目录或者卷（Volume），单个 App 镜像可以用来运行无数个不同业务的容器。</li>
</ul>
<h3 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container 容器"></a>Container 容器</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的<strong>类和实例</strong>一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<h3 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h3><p>Docker 支持通过扩展现有镜像，创建新的镜像。<em>实际上，Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。</em></p>
<p><img src="https://mrhelloworld.com/resources/articles/docker/12180844322018196a29c55c8de4a2.png"></p>
<p>从上图可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p>
<p>镜像分层最大的一个好处就是共享资源。比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 /etc 下的文件，这时其他容器的 /etc 是不会被修改的，<strong>修改只会被限制在单个容器内</strong>。这就是容器 <strong>Copy-on-Write</strong> 特性。</p>
<h3 id="容器层"><a href="#容器层" class="headerlink" title="容器层"></a>容器层</h3><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<p><img src="https://mrhelloworld.com/resources/articles/docker/121808444920186f41cc40362cc7ef.png"></p>
<p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有<strong>容器层是可写的，容器层下面的所有镜像层都是只读的</strong>。</p>
<p>镜像层数量可能会很多，<strong>所有镜像层会联合在一起组成一个统一的文件系统</strong>。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。<strong>在容器层中，用户看到的是一个叠加之后的文件系统。</strong>因此便好理解，为什么对基层镜像的修改，会被限制在单一容器内：在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，<strong>立即将其复制到容器层，然后修改之</strong>，这便是 <strong>Copy-on-Write</strong></p>
<table>
<thead>
<tr>
<th align="left">文件操作</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">添加文件</td>
<td align="left">在容器中创建文件时，新文件被添加到容器层中。</td>
</tr>
<tr>
<td align="left">读取文件</td>
<td align="left">在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存。</td>
</tr>
<tr>
<td align="left">修改文件</td>
<td align="left">在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</td>
</tr>
<tr>
<td align="left">删除文件</td>
<td align="left">在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中<strong>「记录下此删除操作」</strong>。（只是记录删除操作）</td>
</tr>
</tbody></table>
<h3 id="Volume-数据卷"><a href="#Volume-数据卷" class="headerlink" title="Volume 数据卷"></a>Volume 数据卷</h3><p>数据卷可以将数据持久化到我们本地的宿主机上，与容器间实现数据共享，简单的说就是将宿主机的目录映射到容器中的目录，应用程序在容器中的目录读写数据会同步到宿主机上，这样容器产生的数据就可以持久化了，比如我们的数据库容器，就可以把数据存储到我们宿主机上的真实磁盘中。</p>
<h3 id="Registry-注册中心"><a href="#Registry-注册中心" class="headerlink" title="Registry 注册中心"></a>Registry 注册中心</h3><p>Docker 用 Registry 来保存用户构建的镜像。Registry 分为公共和私有两种。</p>
<p>Docker官方运营的Registry为<a href="%5Bhttps://hub.docker.com%5D(https://hub.docker.com/)">Docker Hub</a></p>
<p>一个 Docker Registry 中可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签对应该软件的各个版本。我们可以通过**<code>&lt;仓库名&gt;:&lt;标签&gt;</code> **的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong><code>latest</code></strong> 作为默认标签。</p>
<h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><h3 id="启动Docker服务"><a href="#启动Docker服务" class="headerlink" title="启动Docker服务"></a>启动Docker服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service 命令的用法</span></span><br><span class="line">$ sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># systemctl 命令的用法</span></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><h4 id="列出本机所有镜像"><a href="#列出本机所有镜像" class="headerlink" title="列出本机所有镜像"></a>列出本机所有镜像</h4><p><code>docker image ls</code></p>
<h4 id="删除指定镜像"><a href="#删除指定镜像" class="headerlink" title="删除指定镜像"></a>删除指定镜像</h4><p><code>docker image rm [imageName]</code></p>
<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p><code>docker image pull [imagePath]</code></p>
<p>例如：</p>
<p><code>docker image pull library/hello-world</code></p>
<p>这将会拉取 <code>library</code> 组的 <code>hello-world</code> 镜像，由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p>
<p><code>docker image pull hello-world</code></p>
<h4 id="创建一个容器实例"><a href="#创建一个容器实例" class="headerlink" title="创建一个容器实例"></a>创建一个容器实例</h4><p><code>docker container run [imageName]</code></p>
<p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p>
<p>常用参数：</p>
<ul>
<li><code>-p 3000:8000</code>：容器的 3000 端口映射到本机的 8000 端口。</li>
<li><code>-it</code>：容器的 Shell 映射到当前的 Shell，此时在本机窗口输入的命令，就会传入容器。</li>
<li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li>
<li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令，是<strong>附加指令</strong>。这里是启动 Bash，保证用户可以使用 Shell。</li>
<li><code>--rm</code>：在容器终止后自动销毁容器</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --rm -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure>



<p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p>
<h4 id="启动已有的容器"><a href="#启动已有的容器" class="headerlink" title="启动已有的容器"></a>启动已有的容器</h4><p><code>docker container start [containerID]</code></p>
<h4 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h4><p><code>docker container kill [containerID]</code></p>
<p>或</p>
<p><code> docker container stop [containerID]</code></p>
<p><strong>区别</strong></p>
<p><code>kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>
<p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>
<h4 id="查看容器输出"><a href="#查看容器输出" class="headerlink" title="查看容器输出"></a>查看容器输出</h4><p><code>docker container logs [containerID]</code></p>
<p>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p>
<h4 id="进入一个正在运行的容器"><a href="#进入一个正在运行的容器" class="headerlink" title="进入一个正在运行的容器"></a>进入一个正在运行的容器</h4><p><code>docker container exec [containerID]</code></p>
<p>用于进入一个正在运行的 docker 容器。如果运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。例如：</p>
<p><code>docker container exec -it [containerID] /bin/bash</code></p>
<h4 id="容器文件互拷"><a href="#容器文件互拷" class="headerlink" title="容器文件互拷"></a>容器文件互拷</h4><p>例如将容器中<code>/path/to/fule</code>拷贝到本地</p>
<p><code>docker container cp [containID]:[/path/to/file] .</code></p>
<p>如果需要将本地中文件拷贝到容器中，二者位置调换即可：</p>
<p><code>docker container cp . [containID]:[/path/to/file]</code></p>
<h4 id="列出本机所有容器"><a href="#列出本机所有容器" class="headerlink" title="列出本机所有容器"></a>列出本机所有容器</h4><p><strong>列出本机所有正在运行的容器</strong></p>
<p><code>docker container ls</code></p>
<p><strong>列出本机所有容器（包括终止的容器）</strong></p>
<p><code>docker container ls --all</code></p>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>若要彻底删除容器，则使用以下指令</p>
<p><code>docker container rm [containerID]</code></p>
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><h3 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h3><p>类似于git的<code>.gitignore</code>文件，目的是打包时排除指定的文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">.gitignore</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile 文件是一个文本文件，用来配置 image。Docker 会根据该文件生成二进制的 image 文件。</p>
<p>示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> node demos/01.js</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>FROM node:8.4</code>：表明该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li>
<li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li>
<li><code>WORKDIR /app</code>：表明指定接下来的工作路径为<code>/app</code>。</li>
<li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install --registry=https://registry.npm.taobao.org</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li>
<li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li>
<li><code>CMD node demos/01.js</code>：表示容器启动后自动执行<code>node demos/01.js</code>。</li>
</ul>
<p><strong>注意：</strong><code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件，而<code>CMD</code>命令则是在容器启动后执行。<strong>一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令</strong>。同时在指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令</p>
<h3 id="使用Dockerfile创建image"><a href="#使用Dockerfile创建image" class="headerlink" title="使用Dockerfile创建image"></a>使用Dockerfile创建image</h3><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure>

<p>上面代码中，</p>
<ul>
<li><code>-t</code>参数用来指定 image 文件的名字</li>
<li>冒号用于指定标签。如果不指定，默认的标签就是<code>latest</code>。</li>
<li>最后的点表示 Dockerfile 文件所在的路径</li>
</ul>
<h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p>假设将会在 <code>Docker Hub</code>上发布，首先需要去网站上注册一个账户，然后使用以下指令登陆：</p>
<p><code>docker login</code></p>
<p>接下里便可以为本地的 image 标注用户名和版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure>

<p>也可以不标注用户名，重新构建一下 image 文件。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure>

<p>最后便可以发布 image</p>
<p><code>docker image push [username]/[repository]:[tag]</code></p>
]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次使用脚本帮助抢注ID</title>
    <url>/uncategorized/cks5vvvjr0002wcqve9tjhcwr/</url>
    <content><![CDATA[<h1 id="记一次使用脚本帮助抢注ID"><a href="#记一次使用脚本帮助抢注ID" class="headerlink" title="记一次使用脚本帮助抢注ID"></a>记一次使用脚本帮助抢注ID</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>需求：根据这篇文章指出的网站和方法<a href="https://blog.csdn.net/wade1203/article/details/99791423">收藏！全国计算机二级 Python 题库破解</a> 进行注册，发现ID都被抢注，只能通过脚本批量去试</p>
</li>
<li><p>API：<code>https://python123.io/api/v1/student/courses</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;code&quot;</span>:<span class="string">&quot;C989&quot;</span>,<span class="attr">&quot;passcode&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;student_id&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;张军&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;wertyuil1379@163.com&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>根据当前浏览器中请求的 header 和根据API调用的数据构建data，由于个人用且只需要一个，因此header构建省略，直接通过浏览器访问后截取</p>
<p>因为需要试的ID约有500个，避免请求过多和过于频繁，使用requests.session和time.sleep()</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> requests.api <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://python123.io/api/v1/student/courses&#x27;</span></span><br><span class="line">header=&#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/plain, */*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer 	eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImVtYWlsIjoid2VydHl1aWwxMzc5QDE2My5jb20iLCJuYW1lIjoieFh4IiwiaWQiOiI3MzQ1MjEiLCJvcGVuX2lkIjoid2VjaGF0Om94WjlSMGEwVTlnRWNyOVBpT3ZxYjZDQjQzZjAiLCJyb2xlcyI6WyJzdHVkZW50Il0sImxhc3RfbG9naW4iOjE2MjI5ODE1Njc0MzN9LCJpYXQiOjE2MjI5ODE4NzQsImV4cCI6MTYyNDI3Nzg3NH0.6RepjlBRajrpGxWhGXckO5MiTAChVBE4DVFPOc0EF7M&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-cn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;python123.io&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;https://python123.io&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://python123.io/student/courses&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Length&#x27;</span>: <span class="string">&#x27;95&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;io=y1vqJHgFkMs0e8TpB24-; Hm_lpvt_6f63cfeea8c9a84040e2c4389f01bb91=1622981878; Hm_lvt_6f63cfeea8c9a84040e2c4389f01bb91=1622981492,1622981556; token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImVtYWlsIjoid2VydHl1aWwxMzc5QDE2My5jb20iLCJuYW1lIjoieFh4IiwiaWQiOiI3MzQ1MjEiLCJvcGVuX2lkIjoid2VjaGF0Om94WjlSMGEwVTlnRWNyOVBpT3ZxYjZDQjQzZjAiLCJyb2xlcyI6WyJzdHVkZW50Il0sImxhc3RfbG9naW4iOjE2MjI5ODE1Njc0MzN9LCJpYXQiOjE2MjI5ODE4NzQsImV4cCI6MTYyNDI3Nzg3NH0.6RepjlBRajrpGxWhGXckO5MiTAChVBE4DVFPOc0EF7M; __gads=ID=a7bdd753e07cb1f6-221fdfe43ec90056:T=1622981492:RT=1622981492:S=ALNI_MZXaKIvOdrdV163NPPNyAU6EzK86g&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">s = requests.session()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">500</span>):</span><br><span class="line">    datas = &#123;</span><br><span class="line">        <span class="string">&#x27;code&#x27;</span>:<span class="string">&#x27;C989&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;passcode&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;student_id&#x27;</span>: <span class="built_in">str</span>(<span class="built_in">id</span>),</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;张军&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>:<span class="string">&quot;1340554713@qq.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = s.post(url=url,headers=header,data=json.dumps(datas))</span><br><span class="line"></span><br><span class="line">    res_json = json.loads(res.text)</span><br><span class="line">    <span class="keyword">if</span> res_json[<span class="string">&#x27;code&#x27;</span>] != <span class="number">400</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;FOUND IT !&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">id</span>)))</span><br><span class="line">        <span class="built_in">print</span>(res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        exit(<span class="string">&#x27;STOP&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;id:&#123;a&#125;————&#123;b&#125;&#x27;</span>.<span class="built_in">format</span>(a=<span class="built_in">str</span>(<span class="built_in">id</span>),b=res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;message&#x27;</span>]))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        res.keep_alive = <span class="literal">False</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">id</span>:<span class="number">495</span>————当前学号已被绑定</span><br><span class="line"><span class="built_in">id</span>:<span class="number">496</span>————当前学号已被绑定</span><br><span class="line"><span class="built_in">id</span>:<span class="number">497</span>————当前学号已被绑定</span><br><span class="line"><span class="built_in">id</span>:<span class="number">498</span>————当前学号已被绑定</span><br><span class="line"><span class="built_in">id</span>:<span class="number">499</span>————当前学号已被绑定</span><br></pre></td></tr></table></figure>

<p>一个能用的都没有。。。</p>
<p>那篇文章说只有500左右个学号，然而实践证明远不止这点（应该是后加的）</p>
<p>于是将范围拓宽到1000，最终爬到了学号882</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FOUND IT !<span class="number">882</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/zyon/Desktop/test.py&quot;</span>, line <span class="number">38</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(res_json[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">KeyError: <span class="string">&#x27;message&#x27;</span></span><br></pre></td></tr></table></figure>

<p>因为不知道成功后返回的JSON，因此之前根据错误返回猜的代码有点错误，不过不用，目的已经达成。</p>
]]></content>
  </entry>
  <entry>
    <title>记录一次使用Docker部署Hexo</title>
    <url>/uncategorized/cks5vvvjt0005wcqv6908hr69/</url>
    <content><![CDATA[<h1 id="记录一次使用Docker部署Hexo"><a href="#记录一次使用Docker部署Hexo" class="headerlink" title="记录一次使用Docker部署Hexo"></a>记录一次使用Docker部署Hexo</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于对Node并不熟悉，尚处于初学阶段，因此为熟悉刚学习的Docker以及避免造成本地环境的混乱，将借助Docker来部署Hexo，最后再移到Gitee Page上。</p>
<h2 id="使用NPM安装Hexo"><a href="#使用NPM安装Hexo" class="headerlink" title="使用NPM安装Hexo"></a>使用NPM安装Hexo</h2><p><em>在开始之前，建议先自行百度Docker换源</em></p>
<p>首先拉取 Node 镜像（其实启动镜像实例时会自动拉取）</p>
<p><code>docker image pull node</code></p>
<p>拉取成功后启动</p>
<p><code>docker container run -p 4000:4000 -it node /bin/bash</code></p>
<p>这里将容器4000端口与本地的4000端口进行了绑定</p>
<p>随后便可以开始下载Hexo，下载之前，照例先给NPM换源（淘宝源）：</p>
<p><code>npm config set registry https://registry.npm.taobao.org</code></p>
<p>之后便可以用Hexo官网的指令进行部署：</p>
<p><code>npm install hexo-cli -g</code></p>
<h2 id="Hexo初始化配置"><a href="#Hexo初始化配置" class="headerlink" title="Hexo初始化配置"></a>Hexo初始化配置</h2><p>Hexo安装完成后便可以按照<a href="https://hexo.io/zh-cn/docs/setup">官方文档</a>继续。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init blog		<span class="comment"># 创建blog文件</span></span><br></pre></td></tr></table></figure>

<p>报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/hexojs/hexo-starter.git/&#x27;</span>: gnutls_handshake() failed: The TLS connection was non-properly terminated.</span><br><span class="line">WARN  git <span class="built_in">clone</span> failed. Copying data instead</span><br></pre></td></tr></table></figure>

<p>尝试曲线救国：</p>
<p>在gitee上找到了一个仓库，尝试拉取并安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://gitee.com/jiabintd/hexo-starter hexo-starter</span><br><span class="line">$ <span class="built_in">cd</span> hexo-starter</span><br><span class="line">$ npm isntall</span><br></pre></td></tr></table></figure>

<p>再次进入<code>blog</code>尝试安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>随后便可以使用以下指令启动Hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>现在先暂时使用 <kbd>Ctrl</kbd>+<kbd>C</kbd>关闭Hexo来进行博客站配置</p>
<p>首先是<code>_config.yml</code>文件，坑爹的来了，容器中常用的nano、vim甚至vi都没有，换源都难，只能先忍着速度来一波<code>apt update</code>了，然后建议先安装nano（小，快）进行换源后再考虑vim</p>
<p>根据官方文档简单配置下<code>_config.yml</code>即可，接下来便是下载一个好看的主题，这里选用的是<a href="https://github.com/zhwangart/hexo-theme-ocean">zhwangart/hexo-theme-ocean</a>，该主题有完整的<a href="https://zhwangart.com/2018/11/30/Ocean/">中文文档</a></p>
<p>主题安装完毕后便是再根据主题文档来配置</p>
<p>这里写一个踩坑记录，在配置文章链接时候，修改成了类似于 <code>:example/:title</code>的形式，导致点击文章时变成了下载而不是打开阅读，正确的写法应该要保持<code>/</code>结尾，即应该是<code>:example/:title/</code></p>
<h2 id="使用Hexo-admin管理博客站"><a href="#使用Hexo-admin管理博客站" class="headerlink" title="使用Hexo-admin管理博客站"></a>使用Hexo-admin管理博客站</h2><p>首先是安装：</p>
<p><code>npm install hexo-admin --save</code></p>
<p>随后便可以进入<code>https://xxxx/admin</code>进入后台进行图形化配置</p>
<p>记得根据提示去<code>_config.yml</code>设置密码</p>
<h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><p>本来是想部署到Gitee的，毕竟国内的，访问的快，然鹅最近不让用了，那就只能部署到Github Pages了</p>
<p>首先要做的是git的初始化（因为我是容器环境中）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;你的邮箱地址&quot;</span></span><br></pre></td></tr></table></figure>

<p><em>这里是对全局设置，你可以对单一仓库去掉<code>--global</code>参数来针对性设置</em></p>
<p>之后安装部署工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后需要在配置文件中修改以下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># github仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="comment"># 提交分支，注意GitHub已经将默认主分支设定为main，但最好不要提交到main或master上</span></span><br><span class="line">  <span class="attr">message:</span> <span class="comment"># 提交信息，可以不管</span></span><br></pre></td></tr></table></figure>

<p>这里有一点坑，请务必按照以下步骤来</p>
<p>先清理一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean </span><br></pre></td></tr></table></figure>

<p>然后便可以使用以下命令进行部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>

<p>该指令是让Hexo先编译静态文件(<code>g</code>)，然后部署到远程仓库(<code>-d</code>)</p>
<p>如果漏了编译这一步而直接部署，可能会出现本地看着正常，而部署后样式失效的问题</p>
<p>过程中会需要你的GitHub账号和密码，输入即可</p>
<p>在看到输出成功信息后便可以访问了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>

<h2 id="自定义域名解析到Pages"><a href="#自定义域名解析到Pages" class="headerlink" title="自定义域名解析到Pages"></a>自定义域名解析到Pages</h2><p>在根目录下添加一个名为 <code>CNAME</code> 的文件，填入域名，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example.com</span><br></pre></td></tr></table></figure>

<p>这一步可以直接在Github Pages页面设置，效果一样</p>
<p>然后使用 ping 命令找出存放博客站的主机ip，直接ping 博客站的地址即可，如<code>xxx.github,io</code></p>
<p>随后需要在DNS解析里添加2个记录，分别是：</p>
<ul>
<li>类型CNAME，记录www，值为<code>xxx.github.io</code></li>
<li>类型A，记录@，值为刚刚拿到的IP</li>
</ul>
<p>这样等待大概10分钟左右便可以使用自定义域名去访问Hexo</p>
]]></content>
  </entry>
  <entry>
    <title>Beautiful Soup学习笔记</title>
    <url>/uncategorized/cks5vvvju0006wcqvev2k6arx/</url>
    <content><![CDATA[<h1 id="Beautiful-Soup学习笔记"><a href="#Beautiful-Soup学习笔记" class="headerlink" title="Beautiful Soup学习笔记"></a>Beautiful Soup学习笔记</h1><p>参考：<a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#">官方中文文档</a></p>
<h2 id="对象的种类"><a href="#对象的种类" class="headerlink" title="对象的种类"></a>对象的种类</h2><p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种: </p>
<ul>
<li><code>    Tag</code> </li>
<li><code>NavigableString</code> </li>
<li><code>BeautifulSoup</code> </li>
<li><code>Comment</code> </li>
</ul>
<h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p><code>Tag</code>对象与XML和HTML原生文档中的 tag 相同，即相当于元素，因此关于 tag 可以直接参考HTML或XML中的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">&gt;&gt;&gt;soup = BeautifulSoup(<span class="string">&#x27;&lt;title&gt;EXAMPLE&lt;/title&gt;&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;soup.title</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">type</span>(soup.title)</span><br><span class="line">&lt;title&gt;EXAMPLE&lt;/title&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Tag</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>每一个<code>Tag</code>都有其名字，使用<code>.name</code>来获取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">&gt;&gt;&gt;soup = BeautifulSoup(<span class="string">&#x27;&lt;title&gt;EXAMPLE&lt;/title&gt;&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;tag = soup.title</span><br><span class="line">&gt;&gt;&gt;tag.name</span><br><span class="line"><span class="string">&#x27;title&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果此时，改变<code>name</code>的值，这将会影响到当前BeautifulSoup的文档（即并不会影响原本的文档内容）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">&gt;&gt;&gt;soup = BeautifulSoup(<span class="string">&#x27;&lt;title&gt;EXAMPLE&lt;/title&gt;&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;tag = soup.title</span><br><span class="line">&gt;&gt;&gt;tag.name = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">&gt;&gt;&gt;tag</span><br><span class="line"><span class="string">&#x27;&lt;p&gt;EXAMPLE&lt;/p&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>综上，可见因为<code>.name</code>因素的存在，<strong>tag可以是根据文档而变的任意值</strong>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">&gt;&gt;&gt;soup = BeautifulSoup(<span class="string">&#x27;&lt;xx&gt;EXAMPLE&lt;/xx&gt;&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;soup.xx		//任意值</span><br><span class="line"><span class="string">&#x27;&lt;xx&gt;EXAMPLE&lt;/xx&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="属性（Attributes）"><a href="#属性（Attributes）" class="headerlink" title="属性（Attributes）"></a>属性（Attributes）</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>一个元素可能拥有多个属性，<code>Tag</code>同样如此，获取属性的操作与字典相同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">&gt;&gt;&gt;soup = BeautifulSoup(<span class="string">&#x27;&lt;h1 style=&quot;color:red;&quot;&gt;EXAMPLE&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;tag = soup.h1</span><br><span class="line">&gt;&gt;&gt;tag.[<span class="string">&#x27;style&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;color:red;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>或者是直接使用<code>.attrs</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">&gt;&gt;&gt;soup = BeautifulSoup(<span class="string">&#x27;&lt;h1 style=&quot;color:red;&quot;&gt;EXAMPLE&lt;/h1&gt;&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;tag = soup.h1</span><br><span class="line">&gt;&gt;&gt;tag.attrs</span><br><span class="line">&#123;<span class="string">&#x27;style&#x27;</span>:<span class="string">&#x27;color:red;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>tag的属性可以被添加,删除或修改，<strong>并且 <code>Tag</code>属性的操作方式与字典相同</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tag[<span class="string">&#x27;class&#x27;</span>] = <span class="string">&#x27;verybold&#x27;</span></span><br><span class="line">tag[<span class="string">&#x27;id&#x27;</span>] = <span class="number">1</span></span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;blockquote class=&quot;verybold&quot; id=&quot;1&quot;&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">&#x27;class&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"></span><br><span class="line">tag[<span class="string">&#x27;class&#x27;</span>]</span><br><span class="line"><span class="comment"># KeyError: &#x27;class&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(tag.get(<span class="string">&#x27;class&#x27;</span>))</span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>

<h4 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h4><p>多值属性，例如以下例子：</p>
<p><code>&lt;div class=&#39;col-md-6 col-sm-12&#39;&gt; ... &lt;/div&gt;</code></p>
<p>获取方法同样如上，但对于多值属性返回类型不再是字符串而是列表</p>
<p><strong>注意：</strong>BeautifulSoup只会将HTML定义为多值的属性以列表返回，因此即是一个属性是多值的，但它不是任何版本HTML定义中的多值属性，依然将会被以字符串形式返回！即<strong>定义为多值属性的属性将以列表返回（即使实际并不多值）非定义多值属性将以字符串返回（即使实际多值）</strong></p>
<p>同时与上同理，修改多值属性，<strong>直接操作列表元素即可</strong>，BeautifulSoup将会自动合并列表中的元素并放入属性值中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;soup = BeautifulSoup(&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">example</span>&quot;&gt;&lt;/<span class="title">div</span>&gt;&#x27;)</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;<span class="title">tag</span> = <span class="title">soup</span>.<span class="title">div</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt;<span class="title">tag</span>[&#x27;<span class="title">class</span>&#x27;] = [&#x27;<span class="title">example</span>&#x27;,&#x27;<span class="title">col</span>-<span class="title">md</span>-6&#x27;]		//直接修改列表</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;<span class="title">tag</span>[&#x27;<span class="title">class</span>&#x27;]</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;<span class="title">tag</span>[&#x27;<span class="title">class</span>&#x27;].<span class="title">append</span>(<span class="params"><span class="string">&#x27;col-sm-12&#x27;</span></span>)		//使用列表的方法</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;<span class="title">tag</span>                        </span></span><br><span class="line"><span class="class">[&#x27;<span class="title">example</span>&#x27;,&#x27;<span class="title">col</span>-<span class="title">md</span>-6&#x27;]</span></span><br><span class="line"><span class="class">[&#x27;<span class="title">example</span>&#x27;,&#x27;<span class="title">col</span>-<span class="title">md</span>-6&#x27;,&#x27;<span class="title">col</span>-<span class="title">sm</span>-12&#x27;]</span></span><br><span class="line"><span class="class">&lt;<span class="title">div</span> <span class="title">class</span>=&quot;<span class="title">example</span> <span class="title">col</span>-<span class="title">md</span>-6 <span class="title">col</span>-<span class="title">sm</span>-12&quot;&gt;&lt;/<span class="title">div</span>&gt;                       </span></span><br></pre></td></tr></table></figure>



<p>如果转换的文档是XML格式,那么tag中不包含多值属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xml_soup = BeautifulSoup(<span class="string">&#x27;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#x27;</span>, <span class="string">&#x27;xml&#x27;</span>)</span><br><span class="line">xml_soup.p[<span class="string">&#x27;class&#x27;</span>]</span><br><span class="line"><span class="comment"># u&#x27;body strikeout&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h2><p>字符串常被包含在tag内.Beautiful Soup用 <code>NavigableString</code> 类来包装tag中的字符串，可以使用<code>.strig</code>来获取 tag 的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(<span class="string">&quot;&lt;title&gt;This is a test&lt;/title&gt;&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.title</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.string</span><br><span class="line"><span class="string">&#x27;This is a test&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="编辑内容"><a href="#编辑内容" class="headerlink" title="编辑内容"></a>编辑内容</h3><p>tag 中的字符串内容<strong>不能编辑</strong>，但可以被替换，如以下使用<code>repalce.with()</code>替换了字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(<span class="string">&quot;&lt;title&gt;This is a test&lt;/title&gt;&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.string.replace_with(<span class="string">&quot;EXAMPLE&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.title</span><br><span class="line"><span class="string">&#x27;EXAMPLE&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>NavigableString</code>对象支持  <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id18">遍历文档树</a> 和 <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id27">搜索文档树</a> 中定义的大部分属性，并非全部。尤其是，一个字符串不能包含其它内容（tag能够包含字符串或是其它tag），字符串不支持 <code>.contents</code> 或 <code>.string</code> 属性或 <code>find()</code> 方法。</p>
<p>如果想在Beautiful Soup之外使用 <code>NavigableString</code> 对象，需要调用 <code>unicode()</code> 方法，将该对象转换成普通的Unicode字符串，否则就算Beautiful Soup已方法已经执行结束，该对象的输出也会带有对象的引用地址。这样会浪费内存。</p>
<h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><p><code>BeautifulSoup</code>对象表示的是一个文档的绝大多数内容，可以把它当成 Tag 对象，支持  <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id18">遍历文档树</a> 和 <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id27">搜索文档树</a> 中定义的大部分属性。</p>
<p><strong>注意</strong>：因为 <code>BeautifulSoup</code> 对象并不是真正的 HTML 或 XML 的 tag ，所以它没有 name 和 attribute 属性。但有时查看它的 <code>.name</code> 属性是很方便的，所以 <strong><code>BeautifulSoup</code> 对象包含了一个值为 “[document]” 的特殊属性 <code>.name</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(<span class="string">&quot;&lt;title&gt;EXAMPLE&lt;/title&gt;&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.name</span><br><span class="line"><span class="string">&#x27;[document]&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="注释以及特殊字符的处理"><a href="#注释以及特殊字符的处理" class="headerlink" title="注释以及特殊字符的处理"></a>注释以及特殊字符的处理</h2><p>虽然以上三个对象几乎覆盖了 HTML 和 XML 文档中的所有内容，但仍然有一些特殊情况无法正常处理</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>如下所示，当尝试输出元素内容时，会将注释输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;title&gt;&lt;!--THIS IS A TEST--&gt;&lt;/title&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.title.string</span><br><span class="line"><span class="string">&#x27;THIS IS A TEST&#x27;</span></span><br></pre></td></tr></table></figure>



<p>但当元素中既有内容又有注释时，该方法便失效了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;title&gt;&lt;!--THIS IS A TEST--&gt;EXAMPLE&lt;/title&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.title.string</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>这是因为，如果 tag 只有一个 <code>NavigableString</code> 子节点，那么可以使用 <code>.string</code> 方法获取内容，但是对于大于1个子节点的情况时，只能使用方法<code>contents</code>。</p>
<p>方法<code>contents</code>会将所有的子节点放入一个列表中，因此可以使用列表的操作方式使用该方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;title&gt;&lt;!--THIS IS A TEST--&gt;EXAMPLE&lt;/title&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.title.contents</span><br><span class="line">[<span class="string">&#x27;THIS IS A TEST&#x27;</span>,<span class="string">&#x27;EXAMPLE&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.title.contents[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;EXAMPLE&#x27;</span></span><br></pre></td></tr></table></figure>



<p>现在回过头来，查看以下特殊情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;title&gt;&lt;!--THIS IS A TEST--&gt;&lt;/title&gt;&quot;</span>		//注意，元素中仅注释内容</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>com = soup.title.string</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(com)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Comment</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以发现对象变成了 <code>Comment</code> 对象，其实该对象是 <code>NavigableString</code> 的之类，但在 HTML 文档时，BeautifulSoup 将会对该对象的内容格式化输出（比如该对象就是注释形式出现），同时类似子类还有： <code>CData</code> , <code>ProcessingInstruction</code> , <code>Declaration</code> , <code>Doctype</code> 等</p>
<h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><h3 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h3><p>一个Tag可能包含多个字符串或其它的Tag，这些都是这个Tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性。</p>
<p>注意: Beautiful Soup中字符串节点不支持这些属性，因为字符串没有子节点</p>
<h4 id="tag名的更进一步操作"><a href="#tag名的更进一步操作" class="headerlink" title="tag名的更进一步操作"></a>tag名的更进一步操作</h4><p>上面已经介绍，可以通过<code>.[name]</code>的方式通过元素名来定位到指定的 tag ，对于包含多个 tag 的 tag ，获取其子 tag 操作方法同样类似，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;div&gt;&lt;p&gt;TEST&lt;/p&gt;&lt;/div&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.div.p</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.string</span><br><span class="line"><span class="string">&#x27;TEST&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="获取多个同名-tag"><a href="#获取多个同名-tag" class="headerlink" title="获取多个同名 tag"></a>获取多个同名 tag</h4><p>上述的操作只会获取第一个元素，要想获取所有该名称的 tag，可以用到方法<code>find_all()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;div&gt;&lt;a&gt;T&lt;/a&gt;&lt;a&gt;E&lt;/a&gt;&lt;a&gt;S&lt;/a&gt;&lt;a&gt;T&lt;/a&gt;&lt;/div&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.div.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">[&lt;a&gt;T&lt;/a&gt;, &lt;a&gt;E&lt;/a&gt;, &lt;a&gt;S&lt;/a&gt;, &lt;a&gt;T&lt;/a&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="获取tag内多个内容（多个NavigableString子节点）"><a href="#获取tag内多个内容（多个NavigableString子节点）" class="headerlink" title="获取tag内多个内容（多个NavigableString子节点）"></a>获取tag内多个内容（多个NavigableString子节点）</h4><p>上面已做介绍，<code>.contents</code>属性会将 tag 内容中所有子节点以列表的方式输出</p>
<p>同时，通过 tag 的 <code>.children</code> 生成器可以直接生成一个可迭代对象，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;title&gt;&lt;!--THIS IS A TEST--&gt;EXAMPLE&lt;/title&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.title</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> child <span class="keyword">in</span> tag.children:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(child)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">THIS IS A TEST</span><br><span class="line">EXAMPLE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="对子孙节点迭代"><a href="#对子孙节点迭代" class="headerlink" title="对子孙节点迭代"></a>对子孙节点迭代</h4><p>上述的 <code>.contents</code> <code>.children</code> 方法只会包含 tag 的子节点，但 <code>descendants</code> 方法这是包含了所有子孙节点，此时，字符串也将会变成子孙节点，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;div&gt;&lt;a style=&#x27;display:block;&#x27;&gt;&lt;b&gt;TEST&lt;/b&gt;&lt;/a&gt;&lt;/div&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.div</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> child <span class="keyword">in</span> tag.descendants:</span><br><span class="line"><span class="meta">... </span>		<span class="built_in">print</span>(child)</span><br><span class="line">...</span><br><span class="line">&lt;a style=<span class="string">&quot;display:block;&quot;</span>&gt;&lt;b&gt;TEST&lt;/b&gt;&lt;/a&gt;</span><br><span class="line">&lt;b&gt;TEST&lt;/b&gt;</span><br><span class="line">TEST</span><br></pre></td></tr></table></figure>

<h4 id="多字符串情况"><a href="#多字符串情况" class="headerlink" title="多字符串情况"></a>多字符串情况</h4><p><code>.strings</code>属性将会创建一个包含所有字符串的迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; html = &#x27;&#x27;&#x27;</span><br><span class="line">		&lt;p&gt;</span><br><span class="line">		希望是附丽于存在的，有存在，便有希望，有希望，便是光明2、哀其不幸，怒其不争。</span><br><span class="line"></span><br><span class="line">　　悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。</span><br><span class="line"></span><br><span class="line">　　伟大的心胸，应该表现出这样的气概——用笑脸来迎接悲惨的厄运，用百倍的勇气来应付一切的不幸。</span><br><span class="line"></span><br><span class="line">　　不满足是向上的齿轮。</span><br><span class="line">　　&lt;/p&gt;</span><br><span class="line">　　&#x27;&#x27;&#x27;</span><br><span class="line">&gt;&gt;&gt; soup = bs(html)</span><br><span class="line">&gt;&gt;&gt; tag = soup.p</span><br><span class="line">&gt;&gt;&gt; for child in tag.strings:</span><br><span class="line">...     print(child)</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">		希望是附丽于存在的，有存在，便有希望，有希望，便是光明2、哀其不幸，怒其不争。</span><br><span class="line"></span><br><span class="line">　　悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。</span><br><span class="line"></span><br><span class="line">　　伟大的心胸，应该表现出这样的气概——用笑脸来迎接悲惨的厄运，用百倍的勇气来应付一切的不幸。</span><br><span class="line"></span><br><span class="line">　　不满足是向上的齿轮。</span><br><span class="line">　　</span><br></pre></td></tr></table></figure>

<p>如果字符串中包含了大量空行或空格，则可以使用 <code>stripped_strings</code> 属性来创建一个去除空格空行的迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> child <span class="keyword">in</span> tag.stripped_strings:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(child)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">希望是附丽于存在的，有存在，便有希望，有希望，便是光明<span class="number">2</span>、哀其不幸，怒其不争。</span><br><span class="line"></span><br><span class="line">　　悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。</span><br><span class="line"></span><br><span class="line">　　伟大的心胸，应该表现出这样的气概——用笑脸来迎接悲惨的厄运，用百倍的勇气来应付一切的不幸。</span><br><span class="line"></span><br><span class="line">　　不满足是向上的齿轮。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><p><code>.parents</code> 属性将会创建一个包含该元素所有父节点的迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;div&gt;&lt;a&gt;&lt;b&gt;TEST&lt;/b&gt;&lt;/a&gt;&lt;/div&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> pa <span class="keyword">in</span> tag.parents:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(pa)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">&lt;a style=<span class="string">&quot;display:block;&quot;</span>&gt;&lt;b&gt;TEST&lt;/b&gt;&lt;/a&gt;</span><br><span class="line">&lt;div&gt;&lt;a style=<span class="string">&quot;display:block;&quot;</span>&gt;&lt;b&gt;TEST&lt;/b&gt;&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">&lt;body&gt;&lt;div&gt;&lt;a style=<span class="string">&quot;display:block;&quot;</span>&gt;&lt;b&gt;TEST&lt;/b&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;a style=<span class="string">&quot;display:block;&quot;</span>&gt;&lt;b&gt;TEST&lt;/b&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;a style=<span class="string">&quot;display:block;&quot;</span>&gt;&lt;b&gt;TEST&lt;/b&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">// BeautifulSoup将会对输入的HTML文档进行自动补全修复</span><br></pre></td></tr></table></figure>

<h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><h5 id="输出兄弟节点"><a href="#输出兄弟节点" class="headerlink" title="输出兄弟节点"></a>输出兄弟节点</h5><p><code>.prettify()</code> 方法将会输出 tag <strong>内</strong>标签的所有兄弟节点（即显示的是该标签子标签的兄弟节点情况，包含子孙节点）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;div&gt;&lt;h1&gt;TEST&lt;/h1&gt;&lt;p&gt;THIS IS A TEST FOR &lt;a&gt;IT&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.p</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tag.prettify())</span><br><span class="line">&lt;p&gt;</span><br><span class="line"> THIS IS A TEST FOR</span><br><span class="line"> &lt;a&gt;</span><br><span class="line">  IT</span><br><span class="line"> &lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(soup.prettify())		//如果直接对BeautifulSoup对象使用将会输出所有html标签</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">   &lt;h1&gt;</span><br><span class="line">    TEST</span><br><span class="line">   &lt;/h1&gt;</span><br><span class="line">   &lt;p&gt;</span><br><span class="line">    THIS IS A TEST FOR</span><br><span class="line">    &lt;a&gt;</span><br><span class="line">     IT</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">   &lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="选择某一兄弟节点"><a href="#选择某一兄弟节点" class="headerlink" title="选择某一兄弟节点"></a>选择某一兄弟节点</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;div&gt;&lt;h1&gt;TEST&lt;/h1&gt;&lt;p&gt;THIS IS A TEST FOR &lt;a&gt;IT&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.p</span><br><span class="line">&gt;&gt;&gt;tag.next_sibling</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;tag.previous_sibling</span><br><span class="line">&lt;h1&gt;TEST&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>如山所示，使用<code>.next_sibling</code>属性时并未输出结果，而 <code>.previous_sibling</code>属性则输出了<code>&lt;h1&gt;</code>b标签，这是因为标签 <code>&lt;p&gt;</code> 与 <code>&lt;h1&gt;</code> 为兄弟节点关系，且<code>h1</code>标签在<code>&lt;p&gt;</code>之前</p>
<h6 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h6><p>如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">				&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;	</span></span><br><span class="line"><span class="string">        	&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.string</span><br><span class="line"><span class="string">&#x27;Elsie&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.next_sibling</span><br><span class="line"><span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.next_sibling.next_sibling</span><br><span class="line">&lt;a <span class="class"><span class="keyword">class</span>=&quot;<span class="title">sister</span>&quot; <span class="title">href</span>=&quot;<span class="title">http</span>:</span>//example.com/lacie<span class="string">&quot; id=&quot;</span>link2<span class="string">&quot;&gt;Lacie&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>重要</strong>：可以发现，tag选中了第一个<code>&lt;a&gt;</code>标签，尝试使用属性<code>.next_sibling</code>时，输出的结果不是第二个<code>&lt;a&gt;</code>标签，反而是一个换行符，而这个换行符的下一个节点才是第二个<code>&lt;a&gt;</code>标签</p>
<h3 id="回退和前进"><a href="#回退和前进" class="headerlink" title="回退和前进"></a>回退和前进</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>TEST<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>...<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于上述代码，HTML解释器会将此转化为一连串事件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[打开html标签] --&gt; B[打开head标签] --&gt; C[打开title标签] --&gt; D[添加字符串 TEST] </span><br><span class="line">D --&gt; E[关闭title标签] --&gt; F[关闭head标签] --&gt; G[...] --&gt; H[关闭html标签]</span><br></pre></td></tr></table></figure>

<p>对于这套流程，BeautifulSoup提供了对应的操作方法</p>
<h4 id="next-element-和-previous-element"><a href="#next-element-和-previous-element" class="headerlink" title=".next_element 和 .previous_element"></a>.next_element 和 .previous_element</h4><p><code>.next_element</code> 属性指向解析过程中下一个被解析的对象（字符串或tag），因此结果可能与 <code>.next_sibling</code>相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#x27;utf-8&#x27;/&gt;&lt;title&gt;TEST&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.head</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.next_element</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>/&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.next_sibling</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.meta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.next_sibling</span><br><span class="line">&lt;title&gt;TEST&lt;/title&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.next_element</span><br><span class="line">&lt;title&gt;TEST&lt;/title&gt;</span><br></pre></td></tr></table></figure>

<p>同理，<code>.previous_element</code>指向上一个被解析对象</p>
<h4 id="next-elements-和-previous-elements"><a href="#next-elements-和-previous-elements" class="headerlink" title=".next_elements 和 .previous_elements"></a>.next_elements 和 .previous_elements</h4><p>通过 <code>.next_elements</code> 和 <code>.previous_elements</code> 的迭代器就可以向前或向后访问文档的解析内容，就好像文档正在被解析一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#x27;utf-8&#x27;&gt;&lt;title&gt;TEST&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = soup.head</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> tag.next_elements:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(element)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>/&gt;</span><br><span class="line">&lt;title&gt;TEST&lt;/title&gt;</span><br><span class="line">TEST</span><br></pre></td></tr></table></figure>

<h3 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h3><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>BeautifulSoup过滤器有以下类型</p>
<ul>
<li>字符串</li>
<li>正则表达式</li>
<li>列表</li>
<li>True</li>
<li>方法</li>
</ul>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>字符串是最简单的过滤器类型，传入一个字符串参数，BeautifulSoup将会匹配与该字符串<strong>完整匹配</strong>的内容，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># [&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;]</span></span><br></pre></td></tr></table></figure>

<p>如果传入字节码参数，Beautiful Soup会当作UTF-8编码，可以传入一段Unicode 编码来避免Beautiful Soup解析编码出错</p>
<h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>如果传入正则表达式作为参数，Beautiful Soup会通过正则表达式的 <code>match()</code> 来匹配内容。下面例子中找出所有以b开头的标签，这表示<code>&lt;body&gt;</code>和<code>&lt;b&gt;</code>标签都应该被找到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(re.<span class="built_in">compile</span>(<span class="string">&quot;^b&quot;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(tag.name)</span><br><span class="line"><span class="comment"># body</span></span><br><span class="line"><span class="comment"># b</span></span><br></pre></td></tr></table></figure>

<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p>如果传入列表参数，Beautiful Soup会<strong>将与列表中任一元素匹配的内容返回</strong>。下面代码找到文档中所有<code>&lt;a&gt;</code>标签和<code>&lt;b&gt;</code>标签:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>])</span><br><span class="line"><span class="comment"># [&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure>

<h5 id="True"><a href="#True" class="headerlink" title="True"></a>True</h5><p><code>True</code> 可以匹配任何值，下面代码查找到所有的tag，但是<strong>不会返回字符串节点</strong>（即字符串）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = <span class="string">&quot;&lt;div&gt;&lt;p&gt;EXAMPLE&lt;/p&gt;&lt;/div&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = bs(html)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="literal">True</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(tag.name)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">html</span><br><span class="line">body</span><br><span class="line">div</span><br><span class="line">p</span><br></pre></td></tr></table></figure>

<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>如果上述的过滤器依然没有合你口味，那么可以自定义一个方法来定义属于你自己的过滤器，但是需要注意的是：这个方法只接受一个元素参数，并且找到对应结果返回 True，否则返回False，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">class_without_id</span>(<span class="params">tag</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> tag.has_attr(<span class="string">&#x27;class&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> has_attr(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.find_all(class_without_id)		//注意调用方式</span><br><span class="line">[&lt;p <span class="class"><span class="keyword">class</span>=&quot;<span class="title">title</span>&quot;&gt;&lt;<span class="title">b</span>&gt;<span class="title">The</span> <span class="title">Dormouse</span>&#x27;<span class="title">s</span> <span class="title">story</span>&lt;/<span class="title">b</span>&gt;&lt;/<span class="title">p</span>&gt;,</span></span><br><span class="line"><span class="class"> &lt;<span class="title">p</span> <span class="title">class</span>=&quot;<span class="title">story</span>&quot;&gt;<span class="title">Once</span> <span class="title">upon</span> <span class="title">a</span> <span class="title">time</span> <span class="title">there</span> <span class="title">were</span>...&lt;/<span class="title">p</span>&gt;,</span></span><br><span class="line"><span class="class"> &lt;<span class="title">p</span> <span class="title">class</span>=&quot;<span class="title">story</span>&quot;&gt;...&lt;/<span class="title">p</span>&gt;]</span></span><br></pre></td></tr></table></figure>

<p>该过滤器寻找不带属性<code>id</code>但是拥有属性<code>class</code>的标签</p>
<p>同理，还可以使用如下的高级方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> NavigableString</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>...		//省略</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">surrounded_by_strings</span>(<span class="params">tag</span>):</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">return</span> (<span class="built_in">isinstance</span>(tag.next_element, NavigableString)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">and</span> <span class="built_in">isinstance</span>(tag.previous_element, NavigableString))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(surrounded_by_strings):</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span> tag.name</span><br><span class="line">...</span><br><span class="line">p</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">p</span><br></pre></td></tr></table></figure>

<p>这是一个寻找前后都有文字标签的例子</p>
<h4 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h4><p><code>def find_all(name,attrs,recursive,string,limit,**kwargs)</code></p>
<p>参数：</p>
<ul>
<li><p>name：</p>
<ul>
<li><code>name</code> 参数可以查找所有名字为 <code>name</code> 的tag。<em>字符串对象会被自动忽略掉</em></li>
</ul>
</li>
<li><p>attrs：</p>
<ul>
<li><p>字典类型，允许定义一个参数字典来搜索包含特殊属性的 tag，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_soup.find_all(attrs=&#123;<span class="string">&quot;data-foo&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># [&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>recursive：</p>
<ul>
<li>布尔类型，调用tag的 <code>find_all()</code> 方法时。Beautiful Soup会检索当前tag的所有子孙节点，<strong>如果只想搜索tag的直接子节点,可以使用参数 <code>recursive=False</code> 。</strong></li>
</ul>
</li>
<li><p>string：</p>
<ul>
<li><p>通过 <code>string</code> 参数可以搜搜文档中的字符串内容。与 <code>name</code> 参数的可选值一样，<code>string</code> 参数接受 <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id30">字符串</a> ， <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id31">正则表达式</a> ， <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id32">列表</a>， <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#true">True</a> 。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(string=<span class="string">&quot;Elsie&quot;</span>)			//字符串</span><br><span class="line"><span class="comment"># [u&#x27;Elsie&#x27;]</span></span><br><span class="line"></span><br><span class="line">soup.find_all(string=[<span class="string">&quot;Tillie&quot;</span>, <span class="string">&quot;Elsie&quot;</span>, <span class="string">&quot;Lacie&quot;</span>])		//列表</span><br><span class="line"><span class="comment"># [u&#x27;Elsie&#x27;, u&#x27;Lacie&#x27;, u&#x27;Tillie&#x27;]</span></span><br><span class="line"></span><br><span class="line">soup.find_all(string=re.<span class="built_in">compile</span>(<span class="string">&quot;Dormouse&quot;</span>))			//正则表达式</span><br><span class="line">[<span class="string">u&quot;The Dormouse&#x27;s story&quot;</span>, <span class="string">u&quot;The Dormouse&#x27;s story&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_the_only_string_within_a_tag</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>Return <span class="literal">True</span> <span class="keyword">if</span> this string <span class="keyword">is</span> the only child of its parent tag.<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (s == s.parent.string)</span><br><span class="line"></span><br><span class="line">soup.find_all(string=is_the_only_string_within_a_tag)			//方法</span><br><span class="line"><span class="comment"># [u&quot;The Dormouse&#x27;s story&quot;, u&quot;The Dormouse&#x27;s story&quot;, u&#x27;Elsie&#x27;, u&#x27;Lacie&#x27;, u&#x27;Tillie&#x27;, u&#x27;...&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**kwargs：</p>
<ul>
<li><p>如果指定名称的参数不是搜索内置的参数名时，会将其当作 tag 的属性来搜索如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="built_in">id</span>=<span class="string">&#x27;foot&#x27;</span>)</span><br><span class="line">soup.find_all(<span class="built_in">id</span>=<span class="literal">True</span>)		//这将匹配所有带有 <span class="built_in">id</span> 属性的对象，无论 <span class="built_in">id</span> 的值是什么</span><br></pre></td></tr></table></figure></li>
<li><p><strong>按CSS搜索</strong></p>
<p>由于<code>class</code>在Python中是保留字，因此使用<code>class_</code>来制定对应的class属性的 tag ，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">&quot;a&quot;</span>, class_=<span class="string">&quot;sister&quot;</span>)</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure>

<p>由于class是多值属性，因此将会通过单一值匹配或者全值完整匹配</p>
</li>
</ul>
</li>
<li><p>limit：</p>
<ul>
<li><p>对于大量内容的HTML文档，检索可能会降低速度，BeautifulSoup提供类似SQL语句中的<code>limit</code>参数，用于限制检索的次数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">&quot;a&quot;</span>, limit=<span class="number">2</span>)		//最大只显示匹配的<span class="number">2</span>个结果</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="像find-all-一样调用-tag"><a href="#像find-all-一样调用-tag" class="headerlink" title="像find_all()一样调用 tag"></a>像find_all()一样调用 tag</h4><p><code>BeautifulSoup</code>对象和<code>Tag</code>对象都可以被当成一个方法使用，这个方法的执行与结果与方法<code>find_all()</code>相同，如下两种情况代码是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//BeautifulSoup对象</span><br><span class="line">soup.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">soup(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">//Tag对象</span><br><span class="line">soup.title.find_all(String=<span class="literal">True</span>)</span><br><span class="line">soup.title(string=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p><code>find()</code>方法相当于<code>limit=1</code>的<code>find_all()</code>，用法一致，唯一区别是：</p>
<p><strong><code>find_all()</code>返回的是包含结果的列表，<code>find()</code>直接返回结果</strong></p>
<p><code>soup.head.title</code> 是 <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id20">tag的名字</a> 方法的简写.这个简写的原理就是多次调用当前tag的 <code>find()</code> 方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.head.title</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;</span></span><br><span class="line"></span><br><span class="line">soup.find(<span class="string">&quot;head&quot;</span>).find(<span class="string">&quot;title&quot;</span>)</span><br><span class="line"><span class="comment"># &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="find-parents-amp-find-parent"><a href="#find-parents-amp-find-parent" class="headerlink" title="find_parents() &amp; find_parent()"></a>find_parents() &amp; find_parent()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_parents</span>(<span class="params">name,attrs,recursive,string,**kwargs </span>)</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">find_parent</span>(<span class="params">name,attrs,recursive,string,**kwargs </span>)</span></span><br></pre></td></tr></table></figure>

<p><code>find_parents()</code> 和 <code>find_parent()</code> 用来搜索当前节点的父辈节点，搜索方法与普通 tag 的搜索方法相同。同理，一个输出完整匹配结果的列表，另一个为字符串</p>
<h4 id="find-next-siblings-和find-next-sibling"><a href="#find-next-siblings-和find-next-sibling" class="headerlink" title="find_next_siblings()和find_next_sibling()"></a>find_next_siblings()和find_next_sibling()</h4><p>这2个方法通过 <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#next-siblings-previous-siblings"><code>.next_siblings</code></a> 属性对当 tag 的所有后面解析的兄弟tag节点进行迭代，<code>find_next_siblings()</code> 方法返回所有符合条件的后面的兄弟节点，<code>find_next_sibling()</code> 只返回符合条件的后面的第一个tag节点。</p>
<h4 id="find-previous-siblings-和find-next-sibling"><a href="#find-previous-siblings-和find-next-sibling" class="headerlink" title="find_previous_siblings()和find_next_sibling()"></a>find_previous_siblings()和find_next_sibling()</h4><p>这2个方法通过 <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#next-siblings-previous-siblings"><code>.previous_siblings</code></a> 属性对当前 tag 的前面解析的兄弟tag节点进行迭代，<code>find_previous_siblings()</code> 方法返回所有符合条件的前面的兄弟节点,，find_previous_sibling()` 方法返回第一个符合条件的前面的兄弟节点。</p>
<h4 id="find-all-next-和find-next"><a href="#find-all-next-和find-next" class="headerlink" title="find_all_next()和find_next()"></a>find_all_next()和find_next()</h4><p>这2个方法通过 <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#next-elements-previous-elements"><code>.next_elements</code></a> 属性对当前tag的之后的 tag 和字符串进行迭代，<code>find_all_next()</code>方法返回所有符合条件的节点， <code>find_next()</code> 方法返回第一个符合条件的节点。</p>
<h4 id="find-all-previous-和find-previous"><a href="#find-all-previous-和find-previous" class="headerlink" title="find_all_previous()和find_previous()"></a>find_all_previous()和find_previous()</h4><p>这2个方法通过 <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#next-elements-previous-elements"><code>.previous_elements</code></a> 属性对当前节点前面的 tag 和字符串进行迭代，<code>find_all_previous()</code> 方法返回所有符合条件的节点，<code>find_previous()</code> 方法返回第一个符合条件的节点。</p>
<p><strong>注意</strong>：</p>
<blockquote>
<p><code>find_all_previous(&quot;p&quot;)</code> 返回了文档中的第一段(class=”title”的那段),但还返回了第二段,<p>标签包含了我们开始查找的<a>标签.不要惊讶,这段代码的功能是查找所有出现在指定<a>标签之前的<p>标签,因为这个<p>标签包含了开始的<a>标签,所以<p>标签一定是在<a>之前出现的.</p>
</blockquote>
<h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><p>Beautiful Soup支持大部分的CSS选择器： <a href="http://www.w3.org/TR/CSS2/selector.html">http://www.w3.org/TR/CSS2/selector.html</a> [<a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id93">6]</a> , 在 <code>Tag</code> 或 <code>BeautifulSoup</code> 对象的 <code>.select()</code> 方法中传入字符串参数,，即可使用CSS选择器的语法找到tag，如下所示：</p>
<p>参考资料：<a href="https://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器参考手册</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.select(<span class="string">&quot;title&quot;</span>)</span><br><span class="line"><span class="comment"># [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;p nth-of-type(3)&quot;</span>)</span><br><span class="line"><span class="comment"># [&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span></span><br><span class="line"></span><br><span class="line">soup.select(<span class="string">&quot;body a&quot;</span>)		//返回了所有匹配的结果</span><br><span class="line"><span class="comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span></span><br></pre></td></tr></table></figure>

<p>除了<code>.select()</code>方法，如果只想要返回首个结果，可以使用<code>.select_one()</code>，它只会返回匹配的第一个结果。</p>
<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><h4 id="添加、修改内容"><a href="#添加、修改内容" class="headerlink" title="添加、修改内容"></a>添加、修改内容</h4><h5 id="NavigableString-和-new-tag"><a href="#NavigableString-和-new-tag" class="headerlink" title="NavigableString()和 .new_tag()"></a>NavigableString()和 .new_tag()</h5><p>如果想要创建一段注释，或 <code>NavigableString</code> 的任何子类、内容等添加到文档中，可以调用 NavigableString 的构造方法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span>)</span><br><span class="line">tag = soup.b</span><br><span class="line">tag.append(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">new_string = NavigableString(<span class="string">&quot; there&quot;</span>)</span><br><span class="line">tag.append(new_string)</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;b&gt;Hello there.&lt;/b&gt;</span></span><br><span class="line">tag.contents</span><br><span class="line"><span class="comment"># [u&#x27;Hello&#x27;, u&#x27; there&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>同时如果想要创建一个注释，只需要使用<code>NavigableString()</code>构造一个新的<code>Comment</code>子类即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> Comment</span><br><span class="line">new_comment = soup.new_string(<span class="string">&quot;Nice to see you.&quot;</span>, Comment)</span><br><span class="line">tag.append(new_comment)</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;b&gt;Hello there&lt;!--Nice to see you.--&gt;&lt;/b&gt;</span></span><br><span class="line">tag.contents</span><br><span class="line"><span class="comment"># [u&#x27;Hello&#x27;, u&#x27; there&#x27;, u&#x27;Nice to see you.&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>创建一个tag最好的方法是调用工厂方法 <code>BeautifulSoup.new_tag()</code> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span>)</span><br><span class="line">original_tag = soup.b</span><br><span class="line"></span><br><span class="line">new_tag = soup.new_tag(<span class="string">&quot;a&quot;</span>, href=<span class="string">&quot;http://www.example.com&quot;</span>)</span><br><span class="line">original_tag.append(new_tag)</span><br><span class="line">original_tag</span><br><span class="line"><span class="comment"># &lt;b&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;&lt;/a&gt;&lt;/b&gt;</span></span><br><span class="line"></span><br><span class="line">new_tag.string = <span class="string">&quot;Link text.&quot;</span></span><br><span class="line">original_tag</span><br><span class="line"><span class="comment"># &lt;b&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;Link text.&lt;/a&gt;&lt;/b&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个参数作为tag的name,是必填,其它参数选填</p>
<h5 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h5><p><code>Tag.append()</code> 方法想tag中添加内容,就好像Python的列表的 <code>.append()</code> 方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&quot;&lt;a&gt;Foo&lt;/a&gt;&quot;</span>)</span><br><span class="line">soup.a.append(<span class="string">&quot;Bar&quot;</span>)</span><br><span class="line"></span><br><span class="line">soup</span><br><span class="line"><span class="comment"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;FooBar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line">soup.a.contents</span><br><span class="line"><span class="comment"># [u&#x27;Foo&#x27;, u&#x27;Bar&#x27;]</span></span><br></pre></td></tr></table></figure>

<h5 id="string"><a href="#string" class="headerlink" title=".string"></a>.string</h5><p>同时也可直接给<code>.string</code>赋值的方式来修改，但是<strong>将会替换掉所有内容</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">markup = <span class="string">&#x27;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line"></span><br><span class="line">tag = soup.a</span><br><span class="line">tag.string = <span class="string">&quot;New link text.&quot;</span></span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;a href=&quot;http://example.com/&quot;&gt;New link text.&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h5><p><code>Tag.insert()</code> 方法与 <code>Tag.append()</code> 方法类似，区别是不会把新元素添加到父节点 <code>.contents</code> 属性的最后，而是把元素插入到指定的位置。与Python列表中的 <code>.insert()</code> 方法的用法下同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">markup = <span class="string">&#x27;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">tag = soup.a</span><br><span class="line"></span><br><span class="line">tag.insert(<span class="number">1</span>, <span class="string">&quot;but did not endorse &quot;</span>)</span><br><span class="line">tag</span><br><span class="line"><span class="comment"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to but did not endorse &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;</span></span><br><span class="line">tag.contents</span><br><span class="line"><span class="comment"># [u&#x27;I linked to &#x27;, u&#x27;but did not endorse&#x27;, &lt;i&gt;example.com&lt;/i&gt;]</span></span><br></pre></td></tr></table></figure>

<h5 id="insert-before-和-insert-after"><a href="#insert-before-和-insert-after" class="headerlink" title="insert_before() 和 insert_after()"></a>insert_before() 和 insert_after()</h5><p><code>insert_before()</code> 方法在当前tag或文本节点前插入内容:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">&quot;&lt;b&gt;stop&lt;/b&gt;&quot;</span>)</span><br><span class="line">tag = soup.new_tag(<span class="string">&quot;i&quot;</span>)</span><br><span class="line">tag.string = <span class="string">&quot;Don&#x27;t&quot;</span></span><br><span class="line">soup.b.string.insert_before(tag)</span><br><span class="line">soup.b</span><br><span class="line"><span class="comment"># &lt;b&gt;&lt;i&gt;Don&#x27;t&lt;/i&gt;stop&lt;/b&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>insert_after()</code> 方法在当前tag或文本节点后插入内容:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.b.i.insert_after(soup.new_string(<span class="string">&quot; ever &quot;</span>))</span><br><span class="line">soup.b</span><br><span class="line"><span class="comment"># &lt;b&gt;&lt;i&gt;Don&#x27;t&lt;/i&gt; ever stop&lt;/b&gt;</span></span><br><span class="line">soup.b.contents</span><br><span class="line"><span class="comment"># [&lt;i&gt;Don&#x27;t&lt;/i&gt;, u&#x27; ever &#x27;, u&#x27;stop&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="清除内容"><a href="#清除内容" class="headerlink" title="清除内容"></a>清除内容</h4><h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p><code>Tag.clear()</code> 方法移除当前tag的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">markup = &#x27;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#x27;</span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">tag = soup.a</span><br><span class="line"></span><br><span class="line">tag.clear()</span><br><span class="line">tag</span><br><span class="line"># &lt;a href=&quot;http://example.com/&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h5 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h5><p><code>PageElement.extract()</code> 方法将当前tag移除文档树,并作为方法结果返回:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">markup = &#x27;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#x27;</span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">a_tag = soup.a</span><br><span class="line"></span><br><span class="line">i_tag = soup.i.extract()</span><br><span class="line"></span><br><span class="line">a_tag</span><br><span class="line"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">i_tag</span><br><span class="line"># &lt;i&gt;example.com&lt;/i&gt;</span><br><span class="line"></span><br><span class="line">print(i_tag.parent)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<p>这个方法实际上产生了2个文档树: 一个是用来解析原始文档的 <code>BeautifulSoup</code> 对象,另一个是被移除并且返回的tag。被移除并返回的tag可以继续调用 <code>extract</code> 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_string = i_tag.string.extract()</span><br><span class="line">my_string</span><br><span class="line"># u&#x27;example.com&#x27;</span><br><span class="line"></span><br><span class="line">print(my_string.parent)</span><br><span class="line"># None</span><br><span class="line">i_tag</span><br><span class="line"># &lt;i&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure>

<h5 id="decompose"><a href="#decompose" class="headerlink" title="decompose()"></a>decompose()</h5><p><code>Tag.decompose()</code> 方法将当前节点移除文档树并完全销毁:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">markup = &#x27;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#x27;</span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">a_tag = soup.a</span><br><span class="line"></span><br><span class="line">soup.i.decompose()</span><br><span class="line"></span><br><span class="line">a_tag</span><br><span class="line"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h5 id="replace-with"><a href="#replace-with" class="headerlink" title="replace_with()"></a>replace_with()</h5><p><code>PageElement.replace_with()</code> 方法移除文档树中的某段内容，并用新tag或文本节点替代它:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">markup = &#x27;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#x27;</span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">a_tag = soup.a</span><br><span class="line"></span><br><span class="line">new_tag = soup.new_tag(&quot;b&quot;)</span><br><span class="line">new_tag.string = &quot;example.net&quot;</span><br><span class="line">a_tag.i.replace_with(new_tag)</span><br><span class="line"></span><br><span class="line">a_tag</span><br><span class="line"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;b&gt;example.net&lt;/b&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><code>replace_with()</code> 方法返回被替代的tag或文本节点,可以用来浏览或添加到文档树其它地方</p>
<h5 id="wrap"><a href="#wrap" class="headerlink" title="wrap()"></a>wrap()</h5><p><code>PageElement.wrap()</code> 方法可以对指定的tag元素进行包装，并返回包装后的结果:</p>
<p><strong>包装即对当前标签额外加一层标签包围，</strong>如下面分别给标签<code>&lt;p&gt;</code>的内容和<code>&lt;p&gt;</code>本身包装了一层<code>&lt;b&gt;</code>和<code>&lt;div&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(&quot;&lt;p&gt;I wish I was bold.&lt;/p&gt;&quot;)</span><br><span class="line">soup.p.string.wrap(soup.new_tag(&quot;b&quot;))</span><br><span class="line"># &lt;b&gt;I wish I was bold.&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">soup.p.wrap(soup.new_tag(&quot;div&quot;))</span><br><span class="line"># &lt;div&gt;&lt;p&gt;&lt;b&gt;I wish I was bold.&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><em>该方法在 Beautiful Soup 4.0.5 中添加</em></p>
<h5 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap()"></a>unwrap()</h5><p><code>Tag.unwrap()</code> 方法与 <code>wrap()</code> 方法相反。将移除指定的 tag 标签，如下所示移除了<code>&lt;i&gt;</code>标签，该方法常被用来进行标记的解包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">markup = &#x27;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#x27;</span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">a_tag = soup.a</span><br><span class="line"></span><br><span class="line">a_tag.i.unwrap()</span><br><span class="line">a_tag</span><br><span class="line"># &lt;a href=&quot;http://example.com/&quot;&gt;I linked to example.com&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>与 <code>replace_with()</code> 方法相同，<code>unwrap()</code> 方法<strong>返回被移除的tag</strong></p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p><code>prettify()</code> 方法将Beautiful Soup的文档树格式化后以Unicode编码输出，每个XML/HTML标签都独占一行，<code>BeautifulSoup</code> 对象和它的tag节点都可以调用 <code>prettify()</code> 方法：</p>
<h3 id="压缩输出"><a href="#压缩输出" class="headerlink" title="压缩输出"></a>压缩输出</h3><p>如果只想得到结果字符串,不重视格式,那么可以对一个 <code>BeautifulSoup</code> 对象或 <code>Tag</code> 对象使用Python的 <code>unicode()</code> 或 <code>str()</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str(soup)</span><br><span class="line"># &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span><br><span class="line"></span><br><span class="line">unicode(soup.a)</span><br><span class="line"># u&#x27;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p><code>str()</code> 方法返回UTF-8编码的字符串,可以指定 <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id55">编码</a> 的设置.</p>
<p>还可以调用 <code>encode()</code> 方法获得字节码或调用 <code>decode()</code> 方法获得Unicode。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>Beautiful Soup输出是会将HTML中的特殊字符转换成Unicode，比如“&lquot;”:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(&quot;&amp;ldquo;Dammit!&amp;rdquo; he said.&quot;)</span><br><span class="line">unicode(soup)</span><br><span class="line"># u&#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\u201cDammit!\u201d he said.&lt;/body&gt;&lt;/html&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>如果将文档转换成字符串，Unicode编码会被编码成UTF-8。这样就无法正确显示HTML特殊字符了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str(soup)</span><br><span class="line"># &#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\xe2\x80\x9cDammit!\xe2\x80\x9d he said.&lt;/body&gt;&lt;/html&gt;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="get-text"><a href="#get-text" class="headerlink" title="get_text()"></a>get_text()</h2><p>如果只想得到tag中包含的文本内容，那么可以用 <code>get_text()</code> 方法，这个方法获取到tag中包含的所有文版内容包括子孙tag中的内容，并将结果作为Unicode字符串返回:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">markup = &#x27;&lt;a href=&quot;http://example.com/&quot;&gt;\nI linked to &lt;i&gt;example.com&lt;/i&gt;\n&lt;/a&gt;&#x27;</span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line"></span><br><span class="line">soup.get_text()</span><br><span class="line">u&#x27;\nI linked to example.com\n&#x27;</span><br><span class="line">soup.i.get_text()</span><br><span class="line">u&#x27;example.com&#x27;</span><br></pre></td></tr></table></figure>

<p>可以通过参数指定tag的文本内容的分隔符:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># soup.get_text(&quot;|&quot;)</span><br><span class="line">u&#x27;\nI linked to |example.com|\n&#x27;</span><br></pre></td></tr></table></figure>

<p>还可以去除获得文本内容的前后空白:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># soup.get_text(&quot;|&quot;, strip=True)</span><br><span class="line">u&#x27;I linked to|example.com&#x27;</span><br></pre></td></tr></table></figure>

<p>或者使用 <a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#strings-stripped-strings"><code>.stripped_strings</code></a> 生成器,获得文本列表后手动处理列表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[text for text in soup.stripped_strings]</span><br><span class="line"># [u&#x27;I linked to&#x27;, u&#x27;example.com&#x27;]</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
